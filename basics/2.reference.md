### reference(참조자)
defining a reference means "letting the compiler know about another identifier".
- 이미 존재하는 변수의 또 다른 이름 (alias)
- 두 개가 아니라 같은 하나의 변수
- 선언 시 반드시 초기화
- null reference 없음
```cpp
#include <iostream>
using namespace std;

int main(){
    int a = 3;
    int& another_a = a; //this is reference

    another_a = 5;
    cout << "a: " << a << endl;
    cout << "another_a: " << another_a << endl; 
}
```

### once became identifier, cannot be the identifier for another
Example:
```cpp
int a = 10;
int &another_a = a;

int b = 5;
another_a = b;
```
this is just overriding the value of a to that of b.

what about a pointer?
```cpp
int a = 10;
int* ptr = &a;

int b = 3;
p = &b; //now referencing b
```

### 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.
- pointers occupy 8 bytes memory (4 bytes in 32 bit architecture)
- reference do not have to be allocated onto the memory location. We can just replace every `another_a` with `a`.
- but it doesn't mean that reference is always not present in the memory. (just saying)

    Example:
    ```cpp
    #include <iostream>

    int change_val(int &p){
        p = 3;
        return 0;
    }

    int main(){
        int number = 5;

        std::cout << number << std::endl; //5
        change_val(number);
        std::cout << number << std::endl; //3
        return 0; 
    }
    ```

### 상수에 대한 레퍼런스
- non-const reference 는 lvalue(실제 변수) 만 참조 가능
- temporary(rvalue)를 참조하면 위험하기 때문에 허용 안 함
- const reference 만 예외적으로 허용
    ```cpp
    #include <iostream>

    int main(){
        /**
        error: non-const lvalue reference to type 'int' 
        cannot bind to a temporary of type 'int'
        */
        // int &ref = 4;
        // std::cout << ref << std::endl;

        const int& ref = 4;
        std::cout << ref << std::endl;
        
        return 0;
    }
    ```

### 레퍼런스의 배열과 배열의 레퍼런스
- `int &arr[10];` → 불가능 (Array of references)
    - 레퍼런스는 반드시 초기화 필요 + 이후 재할당 불가
- `int (&ref)[10];` → 가능 (Reference to array)
