## Process vs Thread

### **Process**
- An independent program in execution.
- Has its **own memory space** (Code, Data, Heap, Stack).
- Processes **do not share memory** with each other by default.
- Context switching is **expensive**.
- A crash in one process **does not affect** others.

### **Thread**
- A single flow of execution within a process.
- Threads **share the same memory** of the parent process (Code, Data, Heap).
- Each thread has its **own Stack**.
- Context switching is **lightweight**.
- A crash in one thread can **affect the entire process**.

### **Key Differences**

| Category | Process | Thread |
|----------|---------|--------|
| Memory | Independent | Shared within process |
| Stack | One per process | One per thread |
| Creation Cost | High | Low |
| Context Switch | Heavy | Light |
| Failure Impact | Isolated | Affects entire process |

### **Quick Analogy**
- **Process = a house**
- **Thread = people inside the same house**  
  They share the house (memory), but each has their own room (stack).

## User-level threads
![Image](https://img.notionusercontent.com/s3/prod-files-secure%2F47d0f1a5-2bc8-4793-8739-b93c68e8d157%2F42d5b86a-370d-431d-800d-1b7393481816%2Fimage.png/size/w=2000?exp=1763873341&sig=Oy34PFx7NWosaKt8E2qnvA3RAWxJHKvZ2M94y7dHFQI&id=2b4a96ff-12e6-80c0-bfbd-c0e79f5be2ad&table=block&userId=da23ca2d-c48f-4dec-bf37-0ac08848eb83)
- OS independent, Thread library part of application runtime, Thread switching is cheap.
- Each process has its own threads library in user space.
- The kernel only schedules processes, not individual threads.
- If one thread performs I/O, the kernel blocks the whole process. As a result, all threads in that process stop running.
- User-level threads can't run in parallel even on multi-core CPUs because the OS only schedules the whole process. They're mainly useful as a structuring tool inside user programs.
- yield control voluntarily, or use timer interrupts to switch automatically.

### OS support for user-level threads blocking calls
![image](https://img.notionusercontent.com/s3/prod-files-secure%2F47d0f1a5-2bc8-4793-8739-b93c68e8d157%2Fdbf26ff2-6c2b-4754-8ccd-e17c63ff57ec%2Fimage.png/size/w=2000?exp=1763874639&sig=0xCmgXCvODZB_M7mIbXunzcGmHxLz77a5b3PwolhUG0&id=2b4a96ff-12e6-8084-a705-e8cc412efa87&table=block&userId=da23ca2d-c48f-4dec-bf37-0ac08848eb83)
- 스레드가 블로킹 호출을 하면 OS가 upcall 핸들러를 호출해 작업이 완료되면 알려주겠다고 알림.

### Kernel-level threads
- The norm in most modern operating systems
![image](https://i.postimg.cc/bY5zwLqh/image-(5).png)
- The process-level scheduler manages which process(P1, P2, P3) is ready to run.
- The thread-level scheduler manages threads (T1, T2, T3) within those precesses.
- Threading is visible to the OS, and the OS provides the thread library.

### Example: Solaris OS
![image](https://i.postimg.cc/fLnMvRgT/image-(6).png)
- The unit of scheduling is the kernel thread.
- user-level threads are scheduled by the user space threads library.
- T1 and T2 operate as co-routines with lowest thread-switching cost
- T3 can run concurrently with T1 or T2, but incurs the higher lwp switching cost.
- T4 and T5 can also run concurrently, but pay a higher switching cost with T3 because they are switch address spaces too.
- K1 and K2 are kernel thread and don't have to change address spaces when switching to each other

### summary
User-level threads are schedules entirely in user space, so they are extremely lightweight and incur no kernel context-switch overhead. But the kernel is unaware of their existence, which means a single blocking system call can stall the entire process, and true multi-core parallelism is impossible without kernel threads backing them. Kernel threads avoid these limitations by being scheduled by the OS, enabling real parallelism and independent blocking, but at the cost of higher switching overhead.