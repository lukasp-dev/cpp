### Protocol Stack
- **Definition: TCP/IP Stack**
    - Application: HTTP, FTP
    - Transport: TCP (reliable), UDP (connectionless)
    - Network: IO (packet forwarding)
    - Link: Ethernet, Wi-Fi

### reliable data transfer mechanisms
#### Stop-and-Wait Protocol
![image](https://i.postimg.cc/jjpNwjL6/image-(11).png)
- The sender sends **one packet at a time**.
- It **waits for an ACK** before sending the next packet.
- So it only needs **one packet buffer**.
- Easy to use but slow if the network delay is long
- Sender / Receiver buffer 
    - Sender buffer: 1개 (보낸 패킷만 저장)
    - Receiver buffer: 1개 받은 패킷만 저장)
- Duplicate Packets (Sequence Number)
    - Stop-and-Wait은 동시에 전송되는 패킷이 1개뿐이므로:
        - sequence number 1비트면 충분 -> 0, 1을 번갈아 사용
        - 같은 번호가 두 번 오면 -> 중복 패킷 (이전 패킷 재전송 된거)
        - Receiver 는 중복 패킷이면 무시하고 ACK 만 보냄
- Stop- and-Wait 의 assumption
    - possible packet loss
    - sequence is guaranteed(동시에 여러 패킷 안보냄)
    - 지연은 있을 수 있는데, 패킷이 섞일 일이 없음
    - 그래서 1-bit sequence number 로 충분
        - 첫 번째 패킷 → seq = 0
        
            다음 패킷 → seq = 1

            그 다음 → seq = 0

            그 다음 → seq = 1

            → 0 ↔ 1 ↔ 0 ↔ 1 이렇게만 반복하면 됨.
    
    반면, 실제 IP 네트워크:
    - 손실 가능
    - 손상 가능
    - 순서 뒤바뀜, 지연, 재전송 발생
    -> 그래서 실제 프로토콜(i.e. TCP) 에서는 단조 증가 sequence number(32bit 등) 를 사용.
- Stop-and-Wait 성능 이슈
    - Stop-and-Wait은 RTT마다 딱 1패킷만 보냄
        - 편도 지연 120ms -> RTT 240ms
        - 1 packet/0.24 s
        -> 초당 약 4개
    - bandwidth 를 높이는 건 도움이 안됌
        - bandwidth: 초당  보내 수 있는 양 -> 장비 업그레이드 
    - latency: 신호가 이동하는 시간 -> 거리 + 빛의 속도
    - 공식
        - `Throughput = PacketSize / RTT`

#### Pipeline Protocol
![image](https://i.postimg.cc/sVT3VLb0/image-(12).png)
- The sender **can send multiple packets continuously** ***without waiting for ACKs.***
- Each packet int the pipeline needs its **own buffer** until it's acknowledged.
- This makes transmission **faster and more efficient**, but uses **more memory** for buffers.

#### What might a packet look like
```c
struct header_t{
    int destination_address;
    int source_address;
    int num_packets;
    int sequence_number;
    int packet_size;
    int checksum;
}

struct packet_t{
    struct header_t header;
    char *data;
}
```

#### Reliable protocol with windowing
![image](https://i.postimg.cc/yxQ0Ny94/Screenshot-2025-11-23-at-7-53-50-PM.png)
- 여러 패킷을 동시에 전송할 수 있게 하여 효율을 높임
- ACK 를 받으면 윈도우를 slide 시켜 다음 패킷을 전송할 수 있게 한다.
- TCP 에서만 가능
    - web browser uses TCP
    - TCP: 연결 지향, 윈도우와 ACK 지원 -> 신뢰성 높은, 순서 보장
    - UDP: 비연결형, 윈도우,ACK 없음 -> 단순하지만 신뢰성 낮음

Q.How long would it take to transmit 100 packets using Sliding Window
with a window size of 5 packets and a round trip time (RTT) of 4ms?
Assume that the time (overhead) to send and receive packets is
negligible.

- 5 packets would have completed transmission within the RTT of 4ms.
- There are 100/5 = 20 windows to be completed.
- 20 * 4ms = 80 (ms)