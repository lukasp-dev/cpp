#### Figures of Merit (핵심 성능 지표)
- specific to file system
    - Fast ***sequential*** access
        - 빠른 순차 접근 -> 예: 동영상 재생, 음악 스트리밍, 대용량 로그 파일 읽기.
    - Fast ***random*** access
        - 빠른 임의 접근 -> 예: 데이터베이스, 가상 메모리 스왑 파일, 츠로그램 실행 시 코드/데이터 점프
- common concerns to VM and file system
    - Ability to ***grow*** the file
        - 파일 확장 용이성 -> 예: 로그 파일이 계속 커지는 서버, 문서 편집 시 자동 저장
    - ***Easy allocation*** fo storage
        - 저장공간 할당의 용이성 -> 예: 새 파일을 자주 만들고 지우는 시스템(예: 빌드 서버, 캐시 시스템).
    - Efficiency of ***space utilization*** on the disk
        - Concerns of internal and external fragmentation
        - 공간 활용 효율성 -> 예: 수많은 작은 파일을 저장하는 웹 서버나 이메일 서버에서 단편화 최소화.
- 결론: Growth, time, space, sequential access, random access 가 중요하다. 

### File Allocation Scheme

#### Contiguous Allocation
파일의 디스크의 연속된 블록 구간에 저장하는 방식. 파일은 `(시작 블록, 길이)` 두 값으로 표현한다.
- 필요한 데이터 구조
    - 1) Name Table
        파일 이름 -> 파일의 시작 브록 + 파일 길이
            - `/foo`-> start=20, length=10
            - `/bar`-> start=40, length=5
    - 2) Free List of Disk Blocks
        "사용되지 않은 연속 구간"을 관리하는 리스트. 연속된 빈 구간 (continuous free segments) 을 추적하는 것이 핵심.
        - Where is Free List stored?
            - 1. 디스크에 공식 저장 위치 있음
                - 파일 시스템 메타데이터 영역 
                    - 예: superblock 근처, allocation map, directory metadata 구역
            - 2.실제 동작은 "메모리 캐시"에서 수행
                - free list 에 접근하는 빈도가 매우 높음
                    - 파일 생성, 삭제, 확장 때마다 필요
                - 디스크 읽기는 느리기 때문에 
                    - 성능 때문에 메모리에 올려놓고 캐시 형태로 관리
- Growth X: 파일 뒤에 연속 공간이 없으면 전체 파일을 옮겨야 함. 큰 파일 확장 거의 불가능.
- Time X: 연속된 큰 free 구간을 찾는 데 시간이 오래 걸림. 단편화가 심해질수록 더 느려짐.
- Space X: 외부 단편화 (external fragmentation)기 심함.
- Sequential Access O: 파일이 물리적으로 연속되므로 헤드 이동 거의 없음. 최고 속도.
- Random Access O: 시작 블록 + offset 계산으로 `O(1)` 만에 접근 


#### Linked List Allocation
파일의 각 블록이 ***다음 블록의 주소***를 포함하는 방식. 디스크 상에서 파일이 연결 리스트 형태로 저장됨.
- 블록들이 물리적으로 떨어져 있어도 됨
- 디렉토리에는 파일의 첫 번째 블록 주소만 저장됨
- 읽을 때: 첫 블록 -> 포인터 -> 다음 블록 -> ... 순으로 탐색

- Growth O
- Time O -> Block at a time
- Space O -> No external fragmentation
- Sequential mid(-) 
- Random X -> Very dependent on seek time

#### File Allocation Table
![image](https://cdn.hashnode.com/res/hashnode/image/upload/v1710156975197/47137fcf-ca78-4308-8655-6f6307594c16.png?auto=compress,format&format=webp)

- Growth O
- Time O
- Space O
- Sequential access O
- Random access pretty good
    - Still depends on the seek time
    - Less error prone - we can write data blocks before FAT

#### Indexed allocation
![image](https://i.postimg.cc/76pTwp8w/image.png)
파일의 모든 데이터 블록 번호를 "인덱스 블록(index block)" 하나에 모아서 저장하는 방식. UNIX에서는 이 인덱스 블록이 바로 ***inode***이다.
- Growth X
- Time O
- Space O
- Sequential O
- Random pretty good -> same as FAT


#### Multi-level indexed
![image](https://i.postimg.cc/y8vgkJCY/image.png)
This takes multiple levels of indirection to get to data blocks.
- Small files are a big problem with mutilevel indexed allocation -> because the index block(s) take up as much or more space than the file.

#### Hybrid Multilevel Indexed File System
![image](https://i.sstatic.net/4LfZB.png)
- Growth O
- Time O
- Space O
- Sequential O
- Random pretty good -> Same as FAT, still depends on seek time, but can cache i-node and indirect blocks in 

Q. Given the following:
    - Size of index block = 512 bytes
    - Size of data block = 2048 bytes
    - Size of pointer = 8 bytes (to index or data blocks)

The i-node consists of
    
    - 2 direct data block pointers
    - 1 single indirect pointer, and 
    - 1 double indirect pointer

An index block is used for the i-node as well as for the index blocks that store pointers to other index blocks and data blocks.
Note that the index blocks and data blocks are allocated on a need basis.

A) What is the maximum size (in bytes) of a file that can be stored in this file system?
- index block can hold 512/8 = 64 entries
- 2 blocks in i-node
- 64 entries in first-level index
- 64 * 64 entries in second-level index
- ***Total: 4162 blocks * 20248 bytes = 8,523,776 (bytes)***

B) How many data blocks are needed for storing the same data file of 266 KB?
- 266 * 2^10/2048 = 266/2 = 133 blocks

C) How many index blocks are needed for storing a data file of size 266 KB?
- 266 KB are 133 data blocks
- 1 inode + 1 single-indirect index block + (1+2 double-indirect index blocks) = 5
![image](https://i.postimg.cc/Vk2kpXqc/image.png)

#### directories are files that users cannot write

![image](https://i.postimg.cc/HW3Z2zmT/image.png)

#### File System Integrity: Journaling
- file metadata 변경 내용을 실제 file system 에 반영하기 전에 journal 에 먼저 기록
- 복구: 장애 발생 시 저널을 재생(replay) 하여 최근 변경만 복원 -> 전체 검사 (`fsck`)보다 훨씬 빠름
- 예시: `Linux ext3/ext4`, `Windows NTFS`
- 한계: 사용자 데이터의 일관성 보장 X
    - 일부 데이터 블록은 순서가 어긋날 수도
    - 메타 데이터 블록은 저널에서 올바른 순서로 다시 기록

