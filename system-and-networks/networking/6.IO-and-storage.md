### Communication: CPU and I/O Devices
CPU doesn't talk directly to hardware. It communicates through a device controller, which translates CPU commands into device-specific operations
**1.Structure**
- ***Computer (CPU)*** <-> ***Device Controller*** <-> ***Input/Output Device***
- The device controller acts as a middle layer between CPU and hardware.

**2.Interface to CPU**
- Generic part, specific to device type characteristics.
- **How CPU communicates:**
    - **Memory-mapped I/O**
    - **Load/Store instructions**
    - (Alternative: special I/O instructions)
**3.Interface to Device**
- ***specific to device electronics(depends on the hardware)***

**4.Data Movement**
- ***Slow speed*** due to hardware limitations
- Typically done using Programmed I/O (PIO), CPU directly manages data transfer
- ***High speed***
- DMA (Direct Memory Access) and interrupts - allow data transfer without constant CPU involvement

#### Programmed I/O (PIO) -- CPU 가 직접 일함
- **핵심 한 줄 요약**
    - CPU가 장치를 직접 제어, 데이터 이동까지 스스로 처리
    - CPU가 장치 레지스터를 계속 읽으면서 (status polling) 됐냐?를 확인
    -> PIO is too slow for high-speed streaming devices. Modern systems use ***DMA*** so the controller can handle data transfers directly, while the CPu only manages control and status.

#### DMA
CPU 대신 메모리랑 장치 사이에서 데이터를 자동으로 옯겨주는 하드웨어.
CPU는 지시만 하고 (이렇게 옮겨줘!), 실제로 옮기는 일은 DMA가 함.
DMA는 일을 하기 위해 ***다섯 가지 정보***를 알아야 함.
- command register -> 어떤 작업을 할지
- count register -> 얼마나 옮길지
- device address register -> device 에서 어디를 읽고 쓸지
- memory address register -> memory의 어디에 저장할지
- status register -> 끝났는지? 오류났는지? 아직 바쁜지?

***이 레지스터들은 메모리 주소처럼 load/store로 접근함(MIMO)***

***takeaway**
DMA is used instead of PIO for I/O because
- PIO can lose data if the CPU doesn't poll or respond to the interrupt quickly enough
- Serving an interrupt in the CPU is expensive especially if it has to be done for every work of I/O
- A DMA controller can transfer data into memory in fewer cycles than a programmed loop in the CPU

#### 하드 디스크
- Sector: 디스크에서 데이터를 저장하는 가장 작은 단위
- Track: 디스크 포면 위에 있는 동심원 형태의 데이터 저장 경로
- Cylinder: 여러 플래터(디스크)에서 같은 반지름 위치에 있는 트랙의 집합
    - 100 tracks per surface 라고 하면 cylinder 도 100개 인거임
- Shaft: 디스크 플래터를 회전시키는 중심 축
- Recording surface on both sides: 각 플래터의 위아래 양면 모두 데이터를 저장할 수 있음 -> 각 플래터 당 두 개의 헤더

#### Hard Disk Vocab
Say there is a hard disk that has the following specs
***WD Ultrastar DC540***
- 7200 RPM
- Seek: 7.5 ms
- Rot latency: 8 ms
- Surface size: 1.75 TB
- Tot cap: 14 TB
- Xfer rate(maximum transfer rate): 600 MB/sec

***랜덤 접근시***
Q.How long does it take to find a random block on the disk?
`seek-time` + `rotational-latency/2` = 7.5 + 8/2 = 11.5 (ms)

Q.Roughly how many random reads can. you do per second?
1000ms / 11.5 ms = ~87 reads

Q.And the data transfer rate if blocks are 4K bytes?
87*4096 = 356KB/sec
-> 그래서 cylinder 단위로 읽는게 좋다.(랜덤 말고)

#### Metrics
- $p$: number of platters
- $n$: number of surfaces per platter (1 or 2)
- $t$: number of tracks per surface
- $s$: number of sectors per track
- $b$: number of bytes per sector
- $r$: rotational speed of the disk in RPM
- Total capacity of the disk = $(p*n*t*s*b)$ bytes
- Time for one revolutions = 60/$s$ seconds
- Amount of data read in one revolution = $s$*$b$ bytes
- The data transfer rate of the disk: (Amount of data in track)/(time for on revolution) = ($s$*$b$)/(60/$r$)
- Data transfer rate = ($s$ * $b$ * $r$)/60 bytes/second

#### Zone Recording (ZBR)
디스크 바깥쪽 트랙은 안쪽보다 더 길기 때문에, 바깥쪽 트랙에 더 많은 섹터를 배치해 용량과 속도를 올리는 방식.

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/DiskStructure.svg/250px-DiskStructure.svg.png)

#### Disk Scheduling
queue = [98, 183, 37, 122, 14, 124, 65, 67]
head starts at 53

- **FCFS (First-Come, First-Served)**  
  Order: 53 → 98 → 183 → 37 → 122 → 14 → 124 → 65 → 67  
  특징: 단순하고 공정하지만, 헤드 이동 거리가 커서 평균 탐색 시간이 길다.

- **SSTF (Shortest Seek Time First)**  
  Order: 53 → 65 → 67 → 37 → 14 → 98 → 122 → 124 → 183  
  특징: 현재 헤드 위치에서 가장 가까운 요청을 우선 처리. 평균 탐색 시간은 짧지만, 먼 요청이 계속 지연될 수 있다(기아 현상).

- **SCAN (Elevator Algorithm)**  
  Order: 53 → 65 → 67 → 98 → 122 → 124 → 183 → 199 → 37 → 14  
  특징: 헤드가 한 방향으로 이동하며 요청을 처리한 뒤 끝에 도달하면 방향을 반대로 바꾼다. 이동이 균형 잡혀 있고, 응답 시간의 편차가 줄어든다.

- **C‑SCAN (Circular SCAN)**  
  Order: 53 → 65 → 67 → 98 → 122 → 124 → 183 → 199 → 0 → 14 → 37  
  특징: 한 방향으로만 요청을 처리하고 끝에 도달하면 처음으로 되돌아간다. 응답 시간이 일정하고 예측 가능하다.

- **LOOK** 
  Order: 53 → 65 → 67 → 98 → 122 → 124 → 183 → 37 → 14  
  특징: SCAN과 유사하지만, 요청이 있는 마지막 트랙까지만 이동하고 끝까지 가지 않는다. 불필요한 이동이 줄어든다.

- **C‑LOOK**  
  Order: 53 → 65 → 67 → 98 → 122 → 124 → 183 → 14 → 37  
  특징: C‑SCAN과 유사하지만, 요청이 있는 가장 먼 트랙까지만 이동 후 처음 요청으로 점프한다. 효율적이고 응답 시간도 일정하다

#### SSD explanation to come...